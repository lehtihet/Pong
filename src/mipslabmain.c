/* mipslabmain.c
   This file written 2015 by Axel Isaksson,
   modified 2015, 2017 by F Lundevall, 2019 by Oliver Schwalbe Lehtihet, Anton Brask
   Latest update 2019 by Oliver Schwalbe Lehtihet, Anton Brask
   For copyright and licensing, see file COPYING */

#include <stdint.h>   /* Declarations of uint_32 and the like */
#include <stdbool.h>
#include <pic32mx.h>  /* Declarations of system-specific addresses etc */
#include "mipslab.h"  /* Declatations for these labs */

#define EEPROM_ADDR 0x50
#define EEPROM_INTERNAL_COUNT_ADDR 0

void setupPins( void ) {
	uint8_t temp;
	/*
	  This will set the peripheral bus clock to the same frequency
	  as the sysclock. That means 80 MHz, when the microcontroller
	  is running at 80 MHz. Changed 2017, as recommended by Axel.
	*/
	SYSKEY = 0xAA996655;  /* Unlock OSCCON, step 1 */
	SYSKEY = 0x556699AA;  /* Unlock OSCCON, step 2 */
	while(OSCCON & (1 << 21)); /* Wait until PBDIV ready */
	OSCCONCLR = 0x180000; /* clear PBDIV bit <0,1> */
	while(OSCCON & (1 << 21));  /* Wait until PBDIV ready */
	SYSKEY = 0x0;  /* Lock OSCCON */

	/* Set up output pins */
	AD1PCFG = 0xFFFF;
	ODCE = 0x0;
	TRISECLR = 0xFF;
	PORTE = 0x0;

	/* Output pins for display signals */
	PORTF = 0xFFFF;
	PORTG = (1 << 9);
	ODCF = 0x0;
	ODCG = 0x0;
	TRISFCLR = 0x70;
	TRISGCLR = 0x200;

	/* Set up input pins */
	TRISDSET = (1 << 8);
	TRISFSET = (1 << 1);

	/* Set up SPI as master */
	SPI2CON = 0;
	SPI2BRG = 4;
	/* SPI2STAT bit SPIROV = 0; */
	SPI2STATCLR = 0x40;
	/* SPI2CON bit CKP = 1; */
    SPI2CONSET = 0x40;
	/* SPI2CON bit MSTEN = 1; */
	SPI2CONSET = 0x20;
	/* SPI2CON bit ON = 1; */
	SPI2CONSET = 0x8000;

	/* Set up i2c */
	I2C1CON = 0x0;
	/* I2C Baud rate should be less than 400 kHz, is generated by dividing
	the 40 MHz peripheral bus clock down */
	I2C1BRG = 0x0C2;
	I2C1STAT = 0x0;
	I2C1CONSET = 1 << 13; //SIDL = 1
	I2C1CONSET = 1 << 15; // ON = 1
	temp = I2C1RCV; //Clear receive buffer
}

void clearScreen( void ) {
	display_string(0, "");
	display_string(1, "");
	display_string(2, "");
	display_string(3, "");
	display_update();
}

/* Wait for I2C bus to become idle */
void i2c_idle() {
	while(I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
}

/* Send one byte on I2C bus, return ack/nack status of transaction */
bool i2c_send(uint8_t data) {
	i2c_idle();
	I2C1TRN = data;
	i2c_idle();
	return !(I2C1STAT & (1 << 15)); //ACKSTAT
}

/* Receive one byte from I2C bus */
uint8_t i2c_recv() {
	i2c_idle();
	I2C1CONSET = 1 << 3; //RCEN = 1
	i2c_idle();
	I2C1STATCLR = 1 << 6; //I2COV = 0
	return I2C1RCV;
}

/* Send acknowledge conditon on the bus */
void i2c_ack() {
	i2c_idle();
	I2C1CONCLR = 1 << 5; //ACKDT = 0
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send not-acknowledge conditon on the bus */
void i2c_nack() {
	i2c_idle();
	I2C1CONSET = 1 << 5; //ACKDT = 1
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send start conditon on the bus */
void i2c_start() {
	i2c_idle();
	I2C1CONSET = 1 << 0; //SEN
	i2c_idle();
}

/* Send restart conditon on the bus */
void i2c_restart() {
	i2c_idle();
	I2C1CONSET = 1 << 1; //RSEN
	i2c_idle();
}

/* Send stop conditon on the bus */
void i2c_stop() {
	i2c_idle();
	I2C1CONSET = 1 << 2; //PEN
	i2c_idle();
}

uint8_t readEEPROM( int adress ) {
	int low;
	int high;

	if (adress > 255) {
		low = 255;
		high = (adress >> 8);
	} else {
		low = adress;
		high = 0;
	}

	uint8_t tempReturn;
	do {
		i2c_start();
	} while(!i2c_send(EEPROM_ADDR << 1));
	/* Send most sig byte of internal adress */
	i2c_send(high);
	/* Send least sig byte of internal adress */
	i2c_send(low);

	// Repeated start (last bit of adress = 1 = read)
	do {
		i2c_start();
	} while(!i2c_send((EEPROM_ADDR << 1) | 1)); // Read control byte

	// Get byte from adress
	tempReturn = i2c_recv();

	/* To stop receiving, send nack and stop */
	i2c_nack();
	i2c_stop();

	return tempReturn;
}

void writeEEPROM(int data) {
	uint8_t adressCounter = readEEPROM(EEPROM_INTERNAL_COUNT_ADDR);

	int low;
	int high;

	if (adressCounter > 255) {
		low = 255;
		high = (adressCounter >> 8);
	} else {
		low = adressCounter;
		high = 0;
	}
	/* Send start condition and address of the EEPROM with
	write mode (lowest bit = 0) until the EEPROM sends
	acknowledge condition */	
	do {
		i2c_start(); 
	} while(!i2c_send(EEPROM_ADDR << 1)); 
	/* Send most sig byte of internal adress */
	i2c_send(high);
	/* Send least sig byte of internal adress */
	i2c_send(low);
	// Send data to store at adress
	i2c_send(data);
	/* Send stop condition */
	i2c_stop();
	// Finished writing

	adressCounter++; 
	
	do {
		i2c_start(); 
	} while(!i2c_send(EEPROM_ADDR << 1)); 
	i2c_send(EEPROM_INTERNAL_COUNT_ADDR);
	i2c_send(EEPROM_INTERNAL_COUNT_ADDR);
	i2c_send(adressCounter);
	i2c_stop();
}

void resetHighscore( void ) {
	do {
		i2c_start(); 
	} while(!i2c_send(EEPROM_ADDR << 1)); 
	i2c_send(EEPROM_INTERNAL_COUNT_ADDR);
	i2c_send(EEPROM_INTERNAL_COUNT_ADDR);
	i2c_send(1);
	i2c_stop();
}

int main(void) {
	uint8_t temp;

    setupPins();

	display_init();

	clearScreen();

	//resetHighscore(); 

	mainMenu();

	//DATA SHEET:
	// http://ww1.microchip.com/downloads/en/devicedoc/21203m.pdf

	//writeEEPROM(68);
	//temp = readEEPROM(0);

	//char* testchar = (char*)&temp;

	// display_string(0, testchar);
	// display_string(1, "");
	// display_string(2, "");
	// display_string(3, "");
	// display_update();

	// while (1) {

	// }

	pong_init(); /* Do any lab-specific initialization */

	while( 1 )
	{
	  pong(); /* Do lab-specific things again and again */
	}
	return 0;
}